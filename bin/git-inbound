#!/usr/bin/env python

import glob
import os
import shutil
import subprocess
import sys
import tempfile

class GitPusherException(Exception):
    def __init__(self, msg, has_workdir=True):
        self.msg = msg
        self.has_workdir = has_workdir

    def __str__(self):
        return self.msg

class GitPusher(object):
    def __init__(self, args):
        self.args = args
        self.tmpdir = None
        self.patches = None
        self.interactive = True # TODO - get this from config once I'm confident

        p = subprocess.Popen(['git', 'config', '--get', 'inbound.repo'],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.repo = p.stdout.read().strip()
        if not self.repo:
            raise GitPusherException('Missing path to HG repo')

    def _cleanup(self):
        if self.tmpdir:
            shutil.rmtree(self.tmpdir)

        if self.patches:
            p = subprocess.Popen(['hg', 'qpop', '-a'], cwd=self.repo)
            p.wait()
            for patch in self.patches:
                patch = os.path.basename(patch)
                p = subprocess.Popen(['hg', 'qdel', patch], cwd=self.repo)
                p.wait()

    def run(self):
        # Make our working directory
        self.tmpdir = tempfile.mkdtemp(prefix='inbound', dir='/tmp')

        try:
            # Ignore any outstanding changes, don't pass this arg on to hg try
            self.args.remove('--force')
        except ValueError:
            # Ensure there aren't any outstanding changes
            sys.stdout.write('checking git repository...\n')
            p = subprocess.Popen(['git', 'status', '--porcelain', '-z'],
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            p.wait()
            if p.stdout.read():
                raise GitPusherException('You have uncommitted changes')

        # Get the contents of the patches
        sys.stdout.write('making patches...\n')
        p = subprocess.Popen(['git', 'branchseries', '-o', self.tmpdir])
        if p.wait():
            raise GitPusherException('Could not create patches')

        # Make sure our hg repo doesn't have any outstanding changes or patches
        sys.stdout.write('checking hg repository...\n')
        p = subprocess.Popen(['hg', 'qseries'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        p.wait()
        if p.stdout.read().strip():
            raise GitPusherException('Hg repo already has mq patches')

        p = subprocess.Popen(['hg', 'status'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        p.wait()
        if p.stdout.read().strip():
            raise GitPusherException('Hg repo has outstanding changes')

        # Go to our hg repo and update to the latest
        sys.stdout.write('updating hg repository...\n')
        p = subprocess.Popen(['hg', 'pull', '-u'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        if p.wait():
            raise GitPusherException('Could not check out hg repository')

        # Apply the patches
        sys.stdout.write('applying patches...\n')
        self.patches = glob.glob(os.path.join(self.tmpdir, '*.patch'))
        for patch in self.patches:
            p = subprocess.Popen(['hg', 'qimport', patch], cwd=self.repo)
            if p.wait():
                raise GitPusherException('Could not import patch to hg')
            p = subprocess.Popen(['hg', 'qpush'], cwd=self.repo)
            if p.wait():
                raise GitPusherException('Could not apply patch to hg')

        # Finish the queue series
        p = subprocess.Popen(['hg', 'qfinish', '-a'], cwd=self.repo)
        if p.wait():
            self.patches = None
            self._cleanup()
            raise GitPusherException('Could not finish queue series', False)

        if self.interactive:
            p = subprocess.Popen(['hg', 'outgoing'], cwd=self.repo)
            if p.wait():
                self.patches = None
                self._cleanup()
                raise GitPusherException('Could not determine outgoing changes',
                                         False)

            answer = ''
            while answer.strip().lower() not in ('y', 'ye', 'yes', 'n', 'no'):
                answer = raw_input('Are these changes OK [y/n]? ')

            if answer in ('n', 'no'):
                self.patches = None
                self._cleanup()
                raise GitPusherException(
                    'Aborting (leaving patch queue intact)', False)

        # Now we can go around pushing
        sys.stdout.write('running hg push...\n')
        p = subprocess.Popen(['hg', 'push'], cwd=self.repo)
        if p.wait():
            self.patches = None
            self._cleanup()
            raise GitPusherException('hg push failed', False)

        # Get rid of our working copy if everything went well
        sys.stdout.write('cleaning up...\n')
        self._cleanup()

        sys.stdout.write('done!\n')

if __name__ == '__main__':
    try:
        t = GitPusher(sys.argv[1:])
        t.run()
    except GitPusherException, e:
        if e.has_workdir:
            try:
                sys.stderr.write('Working directory at %s\n' % t.tmpdir)
            except:
                sys.stderr.write('No working directory created\n')
        sys.stderr.write('%s\n' % str(e))
        sys.exit(1)
