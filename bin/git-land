#!/usr/bin/env python

import argparse
import glob
import os
import shutil
import subprocess
import sys
import tempfile

class GitPusherException(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

class GitPusher(object):
    def __init__(self, args):
        self._parse_args(args)
        self.tmpdir = None
        self.patches = []
        self.applied_patches = []
        self.base_rev = None

        p = subprocess.Popen(['git', 'config', '--get',
                              '%s.repo' % (self.args.repo,)],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.repo = p.stdout.read().strip()
        if not self.repo:
            raise GitPusherException('Missing path to HG repo')

        p = subprocess.Popen(['git', 'config', '--get',
                              '%s.interactive' % (self.args.repo,)],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        interactive = p.stdout.read().strip().lower()
        self.interactive = interactive not in ['0', 'no', 'f', 'false']

        p = subprocess.Popen(['git', 'config', '--get',
                              '%s.url' % (self.args.repo,)],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.url = p.stdout.read().strip()

    def _parse_args(self, args):
        parser = argparse.ArgumentParser(prog='git land')
        parser.add_argument('-b', '--build', action='append',
                            help='Build type to make')
        parser.add_argument('-p', '--platform', action='append',
                            help='Platforms to build')
        parser.add_argument('-u', '--unittests', action='append',
                            help='Unit tests to run')
        parser.add_argument('-t', '--talos', action='append',
                            help='Talos tests to run')
        parser.add_argument('-e', '--all-emails', action='store_true',
                            help='Send all emails')
        parser.add_argument('-n', '--no-emails', action='store_true',
                            help='Send no email')
        parser.add_argument('-f', '--failure-emails', action='store_true',
                            help='Send only failure emails')
        parser.add_argument('-m', '--mozilla-central', action='store_true',
                            help='Use mozilla-central configuration')
        parser.add_argument('--force', action='store_true',
                            help='Force push (only for pushes to try)')
        parser.add_argument('--tip', action='store_true',
                            help='Push on top of hg tip instead of matching base (only for pushes to try)')
        parser.add_argument('repo', nargs='?', default='try',
                            help='Repository to land to')

        self.args = parser.parse_args()
        if self.args.force and self.args.repo != 'try':
            raise GitPusherException('--force can only be used on try')
        if self.args.tip and self.args.repo != 'try':
            raise GitPusherException('--tip can only be used on try')

    def _build_try_args(self):
        args = []
        if self.args.build:
            for build in self.args.build:
                args.extend(['-b', build])

        if self.args.platform:
            for platform in self.args.platform:
                args.extend(['-p', platform])

        if self.args.unittests:
            for unittest in self.args.unittests:
                args.extend(['-u', unittest])

        if self.args.talos:
            for talos in self.args.talos:
                args.extend(['-t', talos])

        if self.args.all_emails:
            args.append('-e')

        if self.args.no_emails:
            args.append('-n')

        if self.args.failure_emails:
            args.append('-f')

        if self.args.mozilla_central:
            args.append('-m')

        return args

    def cleanup(self):
        if self.tmpdir:
            shutil.rmtree(self.tmpdir)

        if self.applied_patches:
            p = subprocess.Popen(['hg', 'qpop', '-a'], cwd=self.repo)
            p.wait()
            for patch in self.applied_patches:
                patch = os.path.basename(patch)
                p = subprocess.Popen(['hg', 'qdel', patch], cwd=self.repo)
                p.wait()

        if self.base_rev:
            sys.stdout.write('Returning hg repo to default tip...\n')
            p = subprocess.Popen(['hg', 'up', '--rev', 'tip'], cwd=self.repo)
            p.wait()

    def _push_to_try(self):
        sys.stdout.write('running hg try extension...\n')
        args = self._build_try_args()
        p = subprocess.Popen(['hg', 'try'] + args, cwd=self.repo)
        if p.wait():
            raise GitPusherException('hg try failed')

    def _push_to_hg(self):
        # Finish the queue series
        sys.stdout.write('finishing queue series...\n')
        p = subprocess.Popen(['hg', 'qfinish', '-a'], cwd=self.repo)
        if p.wait():
            raise GitPusherException('Could not finish queue series')

        if self.interactive:
            sys.stdout.write('checking outgoing changes...\n')
            p = subprocess.Popen(['hg', 'outgoing'], cwd=self.repo)
            if p.wait():
                raise GitPusherException('Could not determine outgoing changes')

            answer = ''
            while answer.strip().lower() not in ('y', 'ye', 'yes', 'n', 'no'):
                answer = raw_input('Are these changes OK [y/n]? ')

            if answer.strip().lower() in ('n', 'no'):
                raise GitPusherException('Aborting (leaving patch queue intact)')

        # Now we can go around pushing
        sys.stdout.write('running hg push...\n')
        p = subprocess.Popen(['hg', 'push', self.url], cwd=self.repo)
        if p.wait():
            raise GitPusherException('hg push failed')

    def _do_git_log(self, logfmt):
        p = subprocess.Popen(['git', 'log', '-n', '1', self.base_rev,
                              '--pretty=format:%s' % (logfmt,)],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        return p.stdout.read().strip()

    def run(self):
        # Make our working directory
        self.tmpdir = tempfile.mkdtemp(prefix='gitland', dir='/tmp')

        if not self.args.force:
            # Ensure there aren't any outstanding changes
            sys.stdout.write('checking git repository...\n')
            p = subprocess.Popen(['git', 'status', '--porcelain', '-z'],
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            p.wait()
            if p.stdout.read():
                raise GitPusherException('You have uncommitted changes')

        # Get the contents of the patches
        sys.stdout.write('making patches...\n')
        gbs_args = ['git', 'branchseries', '-o', self.tmpdir]
        if self.args.repo == 'try':
            gbs_args.append('--no-coalesce')
            if not self.args.tip:
                gbs_args.append('--print-base')
        p = subprocess.Popen(gbs_args, stdout=subprocess.PIPE)
        if p.wait():
            raise GitPusherException('Could not create patches')
        if self.args.repo == 'try' and not self.args.tip:
            self.base_rev = p.stdout.read().strip()

        # Make sure our hg repo doesn't have any outstanding changes or patches
        sys.stdout.write('checking hg repository...\n')
        p = subprocess.Popen(['hg', 'qapplied'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        p.wait()
        if p.stdout.read().strip():
            raise GitPusherException('Hg repo already has mq patches')

        if not self.args.force:
            p = subprocess.Popen(['hg', 'status'], stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE, cwd=self.repo)
            p.wait()
            if p.stdout.read().strip():
                raise GitPusherException('Hg repo has outstanding changes')

        # Go to our hg repo and update to the latest
        sys.stdout.write('updating hg repository...\n')
        p = subprocess.Popen(['hg', 'pull', '-u'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        if p.wait():
            raise GitPusherException('Could not check out hg repository')

        if self.base_rev:
            sys.stdout.write('finding matching hg base commit...\n')
            commit_user = self._do_git_log('%an <%ae>')
            commit_user = commit_user.replace(' <none@none>', '')
            commit_date = self._do_git_log('%aD')
            search_str = self._do_git_log(' %s')

            p = subprocess.Popen(['hg', 'log', '--user', commit_user,
                                  '--date', commit_date,
                                  '--template', '{node} {desc|firstline}\n'],
                                 cwd=self.repo, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            p.wait()
            commits = []
            for line in p.stdout:
                if search_str in line:
                    commits.append(line.strip().split(' ', 1)[0])
            if len(commits) == 1:
                sys.stdout.write('updating hg repository to matching base '
                                 'commit...\n')
                p = subprocess.Popen(['hg', 'up', '--rev', commits[0]],
                                     cwd=self.repo)
                if p.wait():
                    sys.stdout.write('WARNING: could not update to matching '
                                     'base commit, pushing on top of hg tip '
                                     'instead\n')
            elif len(commits) > 1:
                sys.stdout.write('WARNING: multiple matching hg revs found, '
                                 'pushing on top of hg tip instead\n')
            else:
                sys.stdout.write('WARNING: no matching hg revs found, '
                                 'pushing on top of hg tip instead\n')
        elif self.args.repo == 'try' and not self.args.tip:
            sys.stdout.write('WARNING: no git base rev, pushing on top of hg '
                             'tip\n')

        # Apply the patches
        sys.stdout.write('applying patches...\n')
        self.patches = sorted(glob.glob(os.path.join(self.tmpdir, '*.patch')))
        for patch in self.patches:
            p = subprocess.Popen(['hg', 'qimport', patch], cwd=self.repo)
            if p.wait():
                raise GitPusherException('Could not import patch to hg')
            self.applied_patches.append(patch)
            p = subprocess.Popen(['hg', 'qpush'], cwd=self.repo)
            if p.wait():
                raise GitPusherException('Could not apply patch to hg')

        try:
            if self.args.repo == 'try':
                self._push_to_try()
            else:
                # No patches applied after this point, don't try to pop them
                self.applied_patches = []
                self._push_to_hg()
        finally:
            sys.stdout.write('cleaning up...\n')
            self.cleanup()

        sys.stdout.write('done!\n')

if __name__ == '__main__':
    try:
        t = GitPusher(sys.argv[1:])
    except Exception as e:
        sys.stderr.write('Failed creating pusher: %s' % (e,))
    try:
        t.run()
    except GitPusherException as e:
        t.cleanup()
        sys.stderr.write('%s\n' % (e,))
        sys.exit(1)
