#!/usr/bin/env python

import argparse
import subprocess
import sys

class GitUpdaterException(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

class GitUpdater(object):
    def __init__(self, args):
        self.starting_branch = None
        self._parse_args(args)

        p = subprocess.Popen(['git', 'config', '--get',
                              'update.%s.upstream' % (self.update,)],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.upstream = p.stdout.read().strip()
        if not self.upstream:
            raise GitUpdaterException('No upstream for %s' % (self.update,))

        p = subprocess.Popen(['git', 'config', '--get',
                              'update.%s.remotes' % (self.update,)],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.remotes = p.stdout.read().strip().split()
        if not self.remotes:
            raise GitUpdaterException('No remotes to update for %s' %
                                      (self.update,))

    def _parse_args(self, args):
        p = argparse.ArgumentParser(prog='git update')
        p.add_argument('update', nargs=1, help='Branch to update')

        args = p.parse_args(args)
        self.update = args.update[0]

    def msg(self, msg):
        sys.stdout.write('%s\n' % (msg,))
        sys.stdout.flush()

    def err(self, msg):
        sys.stderr.write('%s\n' % (msg,))

    def cleanup(self):
        self.msg('Cleaning up...')
        if not self.starting_branch:
            return

        p = subprocess.Popen(['git', 'checkout', self.starting_branch],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if p.wait():
            self.err('Failed returning to %s' % (self.starting_branch,))

        self.starting_branch = None

    def run(self):
        self.msg('Checking current branch...')
        p = subprocess.Popen(['git', 'status', '--porcelain', '-z'],
                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        p.wait()
        if p.stdout.read():
            raise GitUpdaterException('You have uncommitted changes')

        p = subprocess.Popen(['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.starting_branch = p.stdout.read().strip()
        if self.starting_branch == 'HEAD':
            raise GitUpdaterException('You appear to be on a detached head')

        if self.starting_branch == self.update:
            # We'll have no cleanup to do
            self.starting_branch = None

        if self.starting_branch is not None:
            self.msg('Switching to branch %s...' % (self.update,))
            p = subprocess.Popen(['git', 'checkout', self.update],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if p.wait():
                raise GitUpdaterException('Failed checking out %s' % (self.update,))

        self.msg('Updating local copy...')
        p = subprocess.Popen(['git', 'fetch', '--all'], stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        if p.wait():
            raise GitUpdaterException('Failed fetching remotes')

        p = subprocess.Popen(['git', 'merge', '--ff-only', self.upstream],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if p.wait():
            raise GitUpdaterException('Merging to %s is not fast-forward' %
                                      (self.update,))

        failed = False
        for remote in self.remotes:
            self.msg('Pushing to %s...' % (remote,))
            p = subprocess.Popen(['git', 'push', remote, self.update])
            sys.stdout.flush()
            if p.wait():
                self.err('Failed pushing to %s' % (remote,))
                failed = True
            self.msg('')

        self.cleanup()
        if failed:
            raise GitUpdaterException('Failed to push to some remotes')

if __name__ == '__main__':
    try:
        u = GitUpdater(sys.argv[1:])
    except GitUpdaterException as e:
        sys.stderr.write('%s\n' % (e,))
        sys.exit(1)
    except Exception as e:
        sys.stderr.write('Failed creating pusher: %s\n' % (e,))
        sys.exit(1)

    try:
        u.run()
        sys.stdout.write('Done.\n')
    except GitUpdaterException as e:
        u.cleanup()
        sys.stderr.write('%s\n' % (e,))
        sys.exit(1)
