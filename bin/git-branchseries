#!/usr/bin/env python

import argparse
import os
import StringIO
import subprocess
import sys

def find_patch_start(revs, filenames, rev_to_idx):
    i = rev_to_idx
    while i > 0:
        if filenames[i].lower().startswith('bug-'):
            # i - 1 because we need to pass the rev *before* the one we want to
            # have as our commit message
            return i - 1
        i -= 1

    # In this case, we've already gotten to the rev before the one we care about
    return i

parser = argparse.ArgumentParser()
parser.add_argument('-o', dest='outdir', default=os.getcwd(),
    help='Directory to output patches to (default: .)')
args = parser.parse_args()

if not os.path.isdir(args.outdir):
    sys.stderr.write('Invalid output directory: %s\n' % (args.outdir,))
    sys.exit(1)

grl = subprocess.Popen(['git', 'rev-list', '^master', 'HEAD'],
    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
revs = map(lambda x: x.strip(), grl.stdout.readlines())
grl.wait()

glg = subprocess.Popen(['git', 'log', '--format=format:%f', 'master..HEAD'],
    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
filenames = map(lambda x: x.strip(), glg.stdout.readlines())
glg.wait()

if not revs:
    sys.stderr.write('Nothing to make patches from!\n')
    sys.exit(1)

# Make a place for our base rev
revs.append('master')
filenames.append('junk')
revs.reverse()
filenames.reverse()

rev_from_idx = rev_to_idx = len(revs) - 1

patches = []
patchnames = []

while rev_from_idx > 0:
    rev_from_idx = find_patch_start(revs, filenames, rev_to_idx)
    rev_from = revs[rev_from_idx]
    rev_to = revs[rev_to_idx]

    patch = StringIO.StringIO()
    gmp = subprocess.Popen(['git', 'mkpatch', rev_from, rev_to],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    patch.writelines((line for line in gmp.stdout))
    gmp.wait()
    patches.insert(0, patch)
    patchnames.insert(0, filenames[rev_from_idx + 1])
    rev_to_idx = rev_from_idx

for i, patch in enumerate(patches):
    fname = '%04d-%s.patch' % (i + 1, patchnames[i])
    fpath = os.path.join(args.outdir, fname)
    with file(fpath, 'w') as f:
        f.write(patch.getvalue())
    patch.close()
