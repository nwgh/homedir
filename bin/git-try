#!/usr/bin/env python

import glob
import os
import shutil
import subprocess
import sys
import tempfile

class GitTryerException(Exception):
    pass

class GitTryer(object):
    def __init__(self, args):
        self.args = args
        self.tmpdir = None
        self.patches = None

        p = subprocess.Popen(['git', 'config', '--get', 'try.repo'],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
        self.repo = p.stdout.read().strip()
        if not self.repo:
            raise GitTryerException, 'Missing path to HG repo'

    def _cleanup(self):
        if self.tmpdir:
            shutil.rmtree(self.tmpdir)

        if self.patches:
            p = subprocess.Popen(['hg', 'qpop', '-a'], cwd=self.repo)
            p.wait()
            for patch in self.patches:
                patch = os.path.basename(patch)
                p = subprocess.Popen(['hg', 'qdel', patch], cwd=self.repo)
                p.wait()

    def run(self):
        # Make our working directory
        self.tmpdir = tempfile.mkdtemp(prefix='try', dir='/tmp')

        try:
            # Ignore any outstanding changes, don't pass this arg on to hg try
            self.args.remove('--force')
        except ValueError:
            # Ensure there aren't any outstanding changes
            sys.stdout.write('checking git repository...\n')
            p = subprocess.Popen(['git', 'status', '--porcelain', '-z'],
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            p.wait()
            if p.stdout.read():
                raise GitTryerException, 'You have uncommitted changes'

        # Get the contents of the patches
        sys.stdout.write('making patches...\n')
        p = subprocess.Popen(['git', 'branchseries', '-o', self.tmpdir])
        if p.wait():
            raise GitTryerException, 'Could not create patches'

        # Make sure our hg repo doesn't have any outstanding changes or patches
        sys.stdout.write('checking hg repository...\n')
        p = subprocess.Popen(['hg', 'qseries'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        p.wait()
        if p.stdout.read().strip():
            raise GitTryerException, 'Hg repo already has mq patches'

        p = subprocess.Popen(['hg', 'status'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        p.wait()
        if p.stdout.read().strip():
            raise GitTryerException, 'Hg repo has outstanding changes'

        # Go to our hg repo and update to the latest
        sys.stdout.write('updating hg repository...\n')
        p = subprocess.Popen(['hg', 'pull', '-u'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, cwd=self.repo)
        if p.wait():
            raise GitTryerException, 'Could not check out hg repository'

        # Apply the patches
        sys.stdout.write('applying patches...\n')
        self.patches = glob.glob(os.path.join(self.tmpdir, '*.patch'))
        for patch in self.patches:
            p = subprocess.Popen(['hg', 'qimport', '-P', patch], cwd=self.repo)
            if p.wait():
                raise GitTryerException, 'Could not apply patch to hg'

        # Use the hg try extension to do the right thing
        sys.stdout.write('running hg try extension...\n')
        p = subprocess.Popen(['hg', 'try'] + self.args, cwd=self.repo)
        if p.wait():
            raise GitTryerException, 'hg try failed'

        # Get rid of our working copy if everything went well
        sys.stdout.write('cleaning up...\n')
        self._cleanup()

        sys.stdout.write('done!\n')

if __name__ == '__main__':
    try:
        t = GitTryer(sys.argv[1:])
        t.run()
    except GitTryerException, e:
        try:
            sys.stderr.write('Working directory at %s\n' % t.tmpdir)
        except:
            sys.stderr.write('No working directory created\n')
        sys.stderr.write('%s\n' % str(e))
        sys.exit(1)
